%!TEX root = forallx.tex
\chapter{Lógica quantificada}
\label{ch.QL}

Este capítulo introduz uma linguagem lógica chamada \textbf{QL}. Ela é uma versão de \emph{lógica quantificada}, porque permite o uso de quantificadores como \emph{todos} e \emph{alguns}. A lógica quantificada também é chamada de \emph{lógica de predicados}, porque as unidades básicas da linguagem são predicados e termos.

\section{De sentenças a predicados}

Considere o seguinte argumento, que é obviamente válido em português (assim como em inglês):

\begin{quote}
Se todo mundo sabe lógica, então ou ninguém vai ficar confuso ou todo mundo vai. Todos ficarão confusos somente se tentarmos acreditar em uma contradição. Esta é uma aula de lógica, então todo mundo sabe lógica.\\[0.3em]
\therefore\ Se não tentarmos acreditar em uma contradição, então ninguém ficará confuso.
\end{quote}

Para simbolizar isso em SL (lógica sentencial/proposicional), precisamos de uma chave de simbolização:

\begin{ekey}
\item[L:] Todos sabem lógica.
\item[N:] Ninguém ficará confuso.
\item[E:] Todos ficarão confusos.
\item[B:] Tentamos acreditar em uma contradição.
\end{ekey}

Note que $N$ e $E$ tratam ambos de pessoas ficarem confusas, mas são duas letras sentenciais distintas. Não poderíamos substituir $E$ por $\enot N$. Por quê? $\enot N$ significa “Não é o caso que ninguém ficará confuso”. Isso é verdadeiro se pelo menos uma pessoa ficar confusa, o que está muito longe de dizer que \emph{todos} ficarão confusos.

Uma vez que usamos letras distintas para $N$ e $E$, apagamos qualquer conexão entre as duas. Elas passam a ser apenas duas sentenças atômicas que podem ser verdadeira ou falsa independentemente. Em português, nunca poderia ser o caso que ao mesmo tempo ninguém e todo mundo esteja confuso. Já em SL, há uma valoração de verdade em que $N$ e $E$ são ambas verdadeiras.

Expressões como “ninguém”, “todo mundo” e “qualquer um” são chamadas de \emph{quantificadores}. Ao traduzir $N$ e $E$ como sentenças atômicas separadas, deixamos de fora a \emph{estrutura quantificacional} dessas sentenças. Felizmente, a estrutura quantificacional não é o que torna este argumento válido. Assim, podemos ignorá-la com segurança. Para ver isso, traduzimos o argumento para SL:

\begin{earg}
\item[] $L \eif (N \eor E)$
\item[] $E \eif B$
\item[] $L$
\item[\therefore] $\enot B \eif N$
\end{earg}

Este é um argumento válido em SL. (Você pode fazer uma tabela-verdade para verificar.)

Agora considere outro argumento, que também é válido em linguagem natural:

\begin{quote}
\label{willard1}
Willard é lógico. Todo lógico usa chapéu engraçado.\\
\therefore\ Willard usa chapéu engraçado.
\end{quote}

Para simbolizá-lo em SL, definimos a chave:

\begin{ekey}
\item[L:] Willard é lógico.
\item[A:] Todo lógico usa chapéu engraçado.
\item[F:] Willard usa chapéu engraçado.
\end{ekey}

Agora simbolizamos o argumento:

\begin{earg}
\item[] $L$
\item[] $A$
\item[\therefore] $F$
\end{earg}

Isto é \emph{inválido} em SL. (Novamente, você pode confirmar com uma tabela-verdade.) Há algo claramente errado aqui, porque o argumento em português é manifestamente válido. A simbolização em SL deixa de fora toda a estrutura importante. Mais uma vez, a tradução para SL ignora a estrutura quantificacional: a frase “Todo lógico usa chapéu engraçado” fala tanto de lógicos quanto de uso de chapéu. Ao não traduzir essa estrutura, perdemos a conexão entre Willard ser lógico e Willard usar chapéu.

Alguns argumentos com estrutura quantificacional podem ser capturados em SL — como o primeiro exemplo — mesmo que SL ignore essa estrutura. Outros argumentos são completamente deturpados em SL — como o segundo exemplo. Note que o problema não é termos cometido um erro de simbolização; essas são as melhores simbolizações que podemos dar \emph{em SL}.

De modo geral, se um argumento contendo quantificadores resulta \emph{válido em SL}, então o argumento em linguagem natural é válido. Se ele resulta \emph{inválido em SL}, não podemos concluir que o argumento em português é inválido. O argumento pode ser válido devido à sua estrutura quantificacional, que a linguagem natural possui e que o argumento em SL não consegue representar.

\nix{Is this true? Is it possible to exploit the independence of N and E?}

De modo semelhante, se uma sentença com quantificadores sai como \emph{tautologia em SL}, então a sentença em linguagem natural é logicamente verdadeira. Se ela aparece como \emph{contingente em SL}, isso pode ocorrer justamente por causa da estrutura quantificacional que é eliminada ao traduzirmos para a linguagem formal.

Para simbolizar argumentos que dependem crucialmente da estrutura quantificacional, precisamos desenvolver uma linguagem lógica diferente. Chamaremos essa linguagem de lógica quantificada, \textbf{QL}.


\section{Blocos de construção de QL}

Assim como sentenças eram a unidade básica da lógica sentencial, os \emph{predicados} serão a unidade básica da lógica quantificada. Um predicado é uma expressão como “é um cachorro”. Isoladamente, isso não é uma sentença: não é nem verdadeira nem falsa. Para que seja verdadeira ou falsa, precisamos especificar algo: quem ou o que é o cachorro?

Os detalhes serão explicados ao longo do capítulo, mas aqui está a ideia básica: em QL, representaremos predicados com letras maiúsculas. Por exemplo, podemos deixar $D$ significar “\blank\ é um cachorro”. Usaremos letras minúsculas como nomes de coisas específicas. Por exemplo, podemos deixar $b$ significar Bertie. A expressão $Db$ será uma sentença em QL. Ela é uma tradução de “Bertie é um cachorro”.

Para representar a estrutura quantificacional, também teremos símbolos para os quantificadores. Por exemplo, “$\exists$” significará “Existe algum \blank”. Assim, para dizer que existe um cachorro, podemos escrever $\exists x Dx$, isto é: existe um $x$ tal que $x$ é um cachorro.

Isso virá depois. Começaremos definindo termos singulares e predicados.


\subsection{Termos singulares}

Em português, um \define{termo singular} é uma palavra ou expressão que se refere a uma pessoa, lugar ou coisa \emph{específica}. A palavra “cachorro” não é um termo singular, pois há muitos cachorros. Já a expressão “o cachorro do Felipe, o Bertie” é um termo singular, pois se refere a um terrier específico.

Um \define{nome próprio} é um termo singular que designa um indivíduo sem descrevê-lo. O nome “Emerson” é um nome próprio, e o nome, por si só, não lhe diz nada sobre Emerson. É verdade que alguns nomes são tradicionalmente dados a meninos e outros a meninas. Se “Jack Hathaway” é usado como termo singular, você pode supor que se refere a um homem. No entanto, o nome não garante que a pessoa designada seja um homem — ou mesmo que a criatura designada seja uma pessoa. Jack poderia ser uma girafa, pelo que o nome, sozinho, permite inferir. Há muita discussão filosófica em torno disso, mas o ponto importante aqui é que um nome é um termo singular porque escolhe um único indivíduo específico.

Outros termos singulares transmitem de forma mais óbvia alguma informação sobre o objeto a que se referem. Por exemplo, você sabe sem mais explicações que “o cachorro do Felipe, o Bertie” é um termo singular que se refere a um cachorro. Uma \define{descrição definida} seleciona um indivíduo por meio de uma descrição única. Em português, descrições definidas são normalmente expressões do tipo “o tal-e-tal”. Elas se referem \emph{à} coisa específica que se encaixa na descrição. Por exemplo, “o membro mais alto do Monty Python” e “o primeiro imperador da China” são descrições definidas. Uma descrição que não seleciona um único indivíduo não é uma descrição definida: “um membro do Monty Python” e “um imperador da China” não são descrições definidas.

Podemos usar nomes próprios e descrições definidas para designar a mesma coisa. O nome próprio “Monte Rainier” nomeia o lugar selecionado pela descrição definida “o pico mais alto do estado de Washington”. As expressões referem-se ao mesmo lugar de maneiras diferentes. Você não aprende quase nada se eu disser que vou ao Monte Rainier, a menos que já saiba alguma geografia. Talvez você deduza que é uma montanha, mas nem isso é garantido; poderia ser uma faculdade, como o Mount Holyoke. Já se eu disser que vou ao pico mais alto do estado de Washington, você sabe imediatamente que vou a uma montanha no estado de Washington.

Em português, a identificação de um termo singular pode depender do contexto; “Willard” significa uma pessoa específica e não apenas alguém chamado Willard; “P.D. Magnus”, como termo singular lógico, significa \emph{eu} (o autor) e não outro P.D. Magnus qualquer. Vivemos bem com esse tipo de ambiguidade na língua natural, mas é importante ter em mente que termos singulares em QL devem se referir a exatamente uma coisa específica.

Em QL, simbolizaremos termos singulares com letras minúsculas de $a$ até $w$. Podemos adicionar subscritos se quisermos usar a mesma letra mais de uma vez. Assim, $a, b, c, \ldots, w, a_1, f_{32}, j_{390}$ e $m_{12}$ são todos termos em QL.

Termos singulares são chamados de \define{constantes} porque escolhem indivíduos específicos. Note que $x, y$ e $z$ não são constantes em QL. Eles serão \define{variáveis}, letras que não designam nenhuma coisa específica. Precisaremos delas quando introduzirmos quantificadores.


\subsection{Predicados}

Os predicados mais simples são propriedades de indivíduos. São coisas que você pode afirmar sobre um objeto. “\blank\ é um cachorro” e “\blank\ é membro do Monty Python” são predicados. Ao traduzir sentenças do português, o termo nem sempre aparece no começo: “Um piano caiu em cima de \blank” também é um predicado. Predicados assim são chamados de \define{unários} ou \define{monádicos}, porque têm apenas um “espaço em branco” a ser preenchido. Um predicado de um lugar e um termo singular combinam-se para formar uma sentença.

Outros predicados tratam da \emph{relação} entre duas coisas. Por exemplo, “\blank\ é maior do que \blank”, “\blank\ está à esquerda de \blank” e “\blank\ deve dinheiro a \blank”. Esses são predicados \define{binários} ou \define{diádicos}, porque precisam ser preenchidos com dois termos para formar uma sentença.

De modo geral, você pode pensar em predicados como sentenças esquemáticas que precisam ser completadas com certo número de termos. Inversamente, é possível partir de sentenças completas e transformá-las em predicados removendo termos. Considere a sentença “Vinnie pegou o carro da família emprestado de Nunzio”. Ao remover um termo singular, podemos reconhecer nessa sentença qualquer um de três predicados monádicos diferentes:

\begin{center}
\blank pegou o carro da família emprestado de Nunzio.\\
Vinnie pegou \blank emprestado de Nunzio.\\
Vinnie pegou o carro da família emprestado de \blank.
\end{center}

Ao remover dois termos singulares, obtemos três predicados diádicos diferentes:

\begin{center}
Vinnie pegou \blank\ emprestado de \blank.\\
\blank\ pegou o carro da família emprestado de \blank.\\
\blank\ pegou \blank\ emprestado de Nunzio.
\end{center}

Ao remover os três termos singulares, obtemos um predicado \define{ternário} ou \define{triádico}:

\begin{center}
\blank\ pegou \blank\ emprestado de \blank.
\end{center}

Se estivermos traduzindo essa sentença para QL, devemos usar um predicado de um, dois ou três lugares? Depende do que queremos poder expressar. Se a única coisa que iremos discutir é o carro da família sendo emprestado, a generalidade do predicado triádico é desnecessária. Se tudo o que precisamos simbolizar são pessoas pegando o carro da família emprestado de Nunzio, então um predicado unário basta.

Em geral, podemos ter predicados com quantos lugares forem necessários. Predicados com mais de um lugar são chamados de \define{poládicos}. Predicados com $n$ lugares são chamados de \define{$n$-ádicos}.

Em QL, simbolizaremos predicados com letras maiúsculas de $A$ a $Z$, com ou sem subscritos. Quando damos uma chave de simbolização para predicados, não usaremos “espaços em branco”, e sim variáveis. Por convenção, constantes são listadas ao final da chave. Assim, poderíamos ter uma chave como:

\begin{ekey}
\item[Ax:] $x$ está com raiva.
\item[Hx:] $x$ está feliz.
\item[T$_1$xy:] $x$ é tão alto quanto ou mais alto que $y$.
\item[T$_2$xy:] $x$ é tão forte quanto ou mais forte que $y$.
\item[Bxyz:] $y$ está entre $x$ e $z$.
\item[d:] Donald
\item[g:] Gregor
\item[m:] Marybeth
\end{ekey}

Podemos simbolizar sentenças que usem qualquer combinação desses predicados e termos. Por exemplo:

\begin{earg}
\nix{I am inclined to change these to Cordelia, Hamlet, and Macbeth}
\item[\ex{terms1}] Donald está com raiva.
\item[\ex{terms2}] Se Donald está com raiva, então Gregor e Marybeth também estão.
\item[\ex{terms3}] Marybeth é pelo menos tão alta e tão forte quanto Gregor.
\item[\ex{terms4}] Donald é mais baixo que Gregor.
\item[\ex{terms5}] Gregor está entre Donald e Marybeth.
\end{earg}

A sentença \ref{terms1} é direta: $Ad$. O “$x$” na entrada da chave “$Ax$” é apenas um marcador de posição; podemos substituí-lo por outros termos ao traduzir.

A sentença \ref{terms2} pode ser parafraseada como “Se $Ad$, então $Ag$ e $Am$”. QL tem todos os conectivos verofuncionais de SL, então traduzimos como $Ad \eif (Ag \eand Am)$.

A sentença \ref{terms3} pode ser traduzida como $T_1mg \eand T_2mg$.

A sentença \ref{terms4} pode parecer exigir um novo predicado. Se só precisássemos simbolizar \emph{essa} sentença, poderíamos definir um predicado $Sxy$ significando “$x$ é mais baixo que $y$”. No entanto, isso ignoraria a conexão lógica entre “mais baixo” e “mais alto”. Considerados apenas como símbolos de QL, não há relação alguma entre $S$ e $T_1$: eles poderiam significar qualquer coisa. Em vez de introduzir um predicado novo, parafraseamos a sentença \ref{terms4} usando predicados já presentes na chave: “Não é o caso que Donald é tão alto quanto ou mais alto que Gregor”. Traduzimos então como $\enot T_1dg$.

A sentença \ref{terms5} exige que prestemos atenção cuidadosa à ordem dos termos na chave. Ela se torna $Bdgm$.


\section{Quantificadores}

Estamos prontos para introduzir os quantificadores. Considere as sentenças:

\begin{earg}
\item[\ex{q.a}] Todo mundo está feliz.
\item[\ex{q.ac}] Todo mundo é pelo menos tão forte quanto Donald.
\item[\ex{q.e}] Alguém está com raiva.
\end{earg}

Pode ser tentador traduzir \ref{q.a} como $Hd \eand Hg \eand Hm$. Mas isso apenas diria que Donald, Gregor e Marybeth estão felizes. Queremos dizer que \emph{todos} estão felizes, mesmo que não tenhamos definido constantes para nomear cada pessoa. Para isso, introduzimos o símbolo “$\forall$”. Ele é chamado de \define{quantificador universal}.

Um quantificador deve sempre ser seguido de uma variável e de uma fórmula que contenha essa variável. Podemos traduzir a sentença \ref{q.a} como $\forall x Hx$. Em português: “Para todo $x$, $x$ está feliz”.

Chamamos “$\forall x$” de um \emph{quantificador-$x$}. A fórmula que segue o quantificador é chamada de \emph{escopo} do quantificador. Daremos uma definição formal de escopo mais adiante, mas intuitivamente é a parte da sentença sobre a qual o quantificador “se aplica”. Em $\forall x Hx$, o escopo do quantificador universal é $Hx$.

A sentença \ref{q.ac} pode ser parafraseada como “Para todo $x$, $x$ é pelo menos tão forte quanto Donald”. Traduzimos como $\forall x T_2xd$.

Nessas sentenças quantificadas, a variável $x$ funciona como um marcador de posição. A expressão $\forall x$ diz que você pode escolher qualquer indivíduo e colocá-lo no lugar de $x$. Não há motivo especial para usar $x$ em vez de outra variável. A sentença $\forall x Hx$ significa exatamente a mesma coisa que $\forall y Hy$, $\forall z Hz$ ou $\forall x_5 Hx_5$.

Para traduzir a sentença \ref{q.e}, introduzimos outro novo símbolo: o \define{quantificador existencial}, “$\exists$”. Assim como o quantificador universal, o quantificador existencial exige uma variável. A sentença \ref{q.e} pode ser traduzida como $\exists x Ax$. Isso significa que existe algum $x$ que está com raiva — mais precisamente, que existe \emph{pelo menos uma} pessoa com raiva. Mais uma vez, a variável é apenas um marcador de posição; poderíamos igualmente ter traduzido \ref{q.e} como $\exists z Az$.

Considere agora:

\begin{earg}
\item[\ex{q.ne}] Ninguém está com raiva.
\item[\ex{q.en}] Há alguém que não está feliz.
\item[\ex{q.na}] Nem todo mundo está feliz.
\end{earg}

A sentença \ref{q.ne} pode ser parafraseada como “Não é o caso que alguém está com raiva”. Podemos traduzi-la usando negação e um quantificador existencial: $\enot \exists x Ax$. Mas \ref{q.ne} também pode ser parafraseada como “Todo mundo não está com raiva”. Nesse caso, podemos traduzi-la usando negação e um quantificador universal: $\forall x \enot Ax$. Ambas as traduções são aceitáveis, porque são logicamente equivalentes. O ponto crucial é se a negação aparece antes ou depois do quantificador.

Em geral, $\forall x\script{A}$ é logicamente equivalente a $\enot\exists x\enot\script{A}$. Isso significa que qualquer sentença que possa ser simbolizada com quantificador universal pode ser simbolizada com um quantificador existencial, e vice-versa. Uma tradução pode parecer mais natural que a outra, mas não há diferença lógica em traduzir com um ou outro quantificador. Em alguns casos, será apenas questão de gosto.

A sentença \ref{q.en} é mais naturalmente parafraseada como “Existe um $x$ tal que $x$ não está feliz”. Assim, $\exists x \enot Hx$. De forma equivalente, poderíamos escrever $\enot\forall x Hx$.

A sentença \ref{q.na} é mais naturalmente traduzida como $\enot\forall x Hx$. Ela é logicamente equivalente à sentença \ref{q.en} e, portanto, também pode ser traduzida como $\exists x \enot Hx$.

Embora tenhamos dois quantificadores em QL, poderíamos ter uma linguagem formal equivalente com apenas um deles. Poderíamos trabalhar só com o quantificador universal, por exemplo, e tratar o quantificador existencial como uma mera convenção notacional. Usamos colchetes “[ ]” para tornar algumas sentenças mais legíveis, mas sabemos que eles são apenas uma forma de parênteses “( )”. Do mesmo modo, poderíamos escrever “$\exists x$” sabendo que isso é apenas uma abreviação para “$\enot \forall x \enot$”. Há uma escolha entre tornar a lógica formalmente simples e torná-la expressivamente simples. Em QL, optamos pela simplicidade expressiva: tanto $\forall$ quanto $\exists$ serão símbolos primitivos de QL.


\subsection{Universo de discurso}

Com a chave de simbolização que temos usado, $\forall xHx$ significa “Todo mundo está feliz”. Mas quem está incluído nesse “todo mundo”? Quando usamos sentenças assim em português, normalmente não queremos dizer todas as pessoas vivas na Terra. Certamente não queremos dizer todas as pessoas que já existiram ou existirão. Normalmente queremos algo mais modesto: todo mundo no prédio, na turma, na sala etc.

Para eliminar essa ambiguidade, precisamos especificar um \define{universo de discurso} — abreviado UD. O UD é o conjunto de coisas sobre as quais estamos falando. Se quisermos falar de pessoas em Chicago, por exemplo, definimos o UD como “pessoas em Chicago”:

\begin{ekey}
\item[UD:] pessoas em Chicago
\end{ekey}

Os quantificadores \emph{varrem} o universo de discurso. Com esse UD, $\forall x$ significa “toda pessoa em Chicago” e $\exists x$ significa “alguma pessoa em Chicago”. Cada constante nomeia um membro do UD, então só podemos usar esse UD com a chave anterior se Donald, Gregor e Marybeth estiverem em Chicago. Se quisermos falar de pessoas em outros lugares, precisamos incluí-las no UD.

Em QL, o UD deve ser \emph{não vazio}; isto é, deve conter pelo menos uma coisa. É possível construir linguagens formais que permitam UDs vazios, mas isso traz complicações.

Mesmo permitir um UD com apenas um membro já pode gerar resultados estranhos. Suponha esta chave:

\begin{ekey}
\item[UD:] a Torre Eiffel
\item[Px:] $x$ está em Paris.
\end{ekey}

A sentença $\forall x Px$ poderia ser parafraseada em português como “Tudo está em Paris”. Mas isso seria enganoso. O que ela realmente diz é que tudo \emph{no UD} está em Paris. Como esse UD contém apenas a Torre Eiffel, com essa chave $\forall x Px$ quer dizer simplesmente que a Torre Eiffel está em Paris.

\subsection{Termos não-referenciais}

Em QL, cada constante deve escolher exatamente um membro do UD. Uma constante não pode se referir a mais de uma coisa — ela é um termo \emph{singular}. E cada constante ainda precisa escolher \emph{alguma} coisa. Isso está ligado a um problema clássico em filosofia: o chamado problema dos \emph{termos não-referenciais}.

Filosofos medievais costumavam usar sentenças sobre a \emph{quimera} para exemplificar esse problema. A quimera é uma criatura mitológica; ela não existe de fato. Considere as duas sentenças:

\begin{earg}
\item[\ex{chimera1}] A quimera está com raiva.
\item[\ex{chimera2}] A quimera não está com raiva.
\end{earg}

É tentador simplesmente definir uma constante para significar “quimera”. A chave de simbolização ficaria assim:

\begin{ekey}
\item[UD:] criaturas na Terra
\item[Ax:] $x$ está com raiva.
\item[c:] a quimera
\end{ekey}

Poderíamos então traduzir a sentença \ref{chimera1} como $Ac$ e a sentença \ref{chimera2} como $\enot Ac$.

Os problemas aparecem quando perguntamos se essas sentenças são verdadeiras ou falsas.

Uma opção seria dizer que a sentença \ref{chimera1} não é verdadeira, porque não há quimera alguma. Se a \ref{chimera1} é falsa por falar de algo que não existe, então a \ref{chimera2} também deveria ser falsa pela mesma razão. Mas isso significaria que $Ac$ e $\enot Ac$ seriam ambas falsas. Dadas as condições de verdade da negação, isso é impossível.

Como não podemos dizer que ambas são falsas, o que fazer? Outra opção seria dizer que a sentença \ref{chimera1} é \emph{sem sentido} (“meaningless”), porque fala de algo que não existe. Assim, $Ac$ seria uma expressão significativa em QL para algumas interpretações, mas não para outras. Isso, porém, tornaria nossa linguagem formal refém de interpretações particulares. Como estamos interessados na forma lógica, queremos considerar a força lógica de uma sentença como $Ac$ independentemente de qualquer interpretação específica. Se $Ac$ às vezes fosse significativa e às vezes não, não poderíamos fazer isso.

Esse é o \emph{problema dos termos não-referenciais}, ao qual retornaremos depois (ver p.~\pageref{subsec.defdesc}.). O ponto importante, por agora, é que cada constante de QL \emph{deve} referir-se a alguma coisa no UD, embora o UD possa ser qualquer conjunto de coisas que quisermos. Se quisermos simbolizar argumentos sobre criaturas mitológicas, então precisamos definir um UD que as inclua. Essa opção é importante se quisermos considerar a lógica de histórias de ficção. Podemos traduzir uma sentença como “Sherlock Holmes morava no 221B Baker Street” incluindo personagens ficcionais como Sherlock Holmes em nosso UD.


\section{Tradução para QL}

Agora já temos todas as peças de QL. Traduzir sentenças mais complicadas será apenas uma questão de saber combinar predicados, constantes, quantificadores, variáveis e conectivos da maneira adequada. Considere estas sentenças:

\begin{earg}
\item[\ex{quan1}] Toda moeda no meu bolso é uma moeda de 25 centavos.
\item[\ex{quan2}] Alguma moeda em cima da mesa é uma moeda de 10 centavos.
\item[\ex{quan3}] Nem todas as moedas em cima da mesa são moedas de 10 centavos.
\item[\ex{quan4}] Nenhuma das moedas do meu bolso é uma moeda de 10 centavos.
\end{earg}

Ao fornecer uma chave de simbolização, precisamos especificar um UD. Como estamos falando de moedas no meu bolso e em cima da mesa, o UD deve pelo menos conter todas essas moedas. Como não estamos falando de nada além de moedas, tomamos o UD como sendo o conjunto de todas as moedas. Como não falamos de moedas específicas, não precisamos definir constantes. Assim, definimos a seguinte chave:

\begin{ekey}
\item[UD:] todas as moedas
\item[Px:] $x$ está no meu bolso.
\item[Tx:] $x$ está em cima da mesa.
\item[Qx:] $x$ é uma moeda de 25 centavos.
\item[Dx:] $x$ é uma moeda de 10 centavos.
\end{ekey}

A sentença \ref{quan1} é mais naturalmente traduzida com um quantificador universal. O quantificador universal diz algo sobre todos os membros do UD, não apenas sobre as moedas no meu bolso. A sentença \ref{quan1} significa que (para qualquer moeda) \emph{se} essa moeda estiver no meu bolso, \emph{então} ela é uma moeda de 25 centavos. Assim, podemos traduzi-la como $\forall x(Px \eif Qx)$.

Como a sentença \ref{quan1} fala de moedas que estão ao mesmo tempo no meu bolso \emph{e} são moedas de 25 centavos, pode ser tentador traduzi-la usando uma conjunção. No entanto, a sentença $\forall x(Px \eand Qx)$ significaria que tudo no UD está no meu bolso e é uma moeda de 25 centavos: todas as moedas que existem são moedas de 25 centavos no meu bolso. Isso seria uma afirmação bastante estranha e significa algo bem diferente de \ref{quan1}.

A sentença \ref{quan2} é mais naturalmente traduzida com um quantificador existencial. Ela afirma que existe alguma moeda que está em cima da mesa e que é uma moeda de 10 centavos. Logo, podemos traduzi-la como $\exists x(Tx \eand Dx)$.

Note que usamos um condicional com o quantificador universal, mas usamos uma conjunção com o quantificador existencial. O que significaria escrever $\exists x(Tx \eif Dx)$? Provavelmente não aquilo que você imagina. Isso significa que existe algum membro do UD que torna verdadeira a subfórmula; de modo aproximado, existe algum $a$ tal que $(Ta \eif Da)$ é verdadeira. Em SL, $\script{A} \eif \script{B}$ é logicamente equivalente a $\enot \script{A} \eor \script{B}$, e isso também vale em QL. Assim, $\exists x(Tx \eif Dx)$ é verdadeira se existe algum $a$ tal que $(\enot Ta \eor Da)$; isto é, ela é verdadeira se alguma moeda é \emph{ou} não está em cima da mesa \emph{ou} é uma moeda de 10 centavos. Mas certamente existe alguma moeda que não está em cima da mesa — há moedas em muitos outros lugares. Então $\exists x(Tx \eif Dx)$ é trivialmente verdadeira. Em geral, um condicional será o conectivo natural para usar com um quantificador universal, mas um condicional dentro do escopo de um quantificador existencial pode produzir resultados muito estranhos. Como regra prática, não coloque condicionais dentro do escopo de quantificadores existenciais a menos que você tenha certeza de que precisa de um.

A sentença \ref{quan3} pode ser parafraseada como: “Não é o caso que toda moeda em cima da mesa seja uma moeda de 10 centavos.” Assim, podemos traduzi-la como $\enot \forall x(Tx \eif Dx)$. Você também pode olhar para \ref{quan3} e parafraseá-la como: “Alguma moeda em cima da mesa não é uma moeda de 10 centavos.” Nesse caso, você a traduziria como $\exists x(Tx \eand \enot Dx)$. Embora isso não seja óbvio à primeira vista, essas duas traduções são logicamente equivalentes. (Isso decorre da equivalência lógica entre $\enot \forall x\script{A}$ e $\exists x\enot\script{A}$, junto com a equivalência entre $\enot(\script{A}\eif\script{B})$ e $\script{A}\eand \enot\script{B}$.)

A sentença \ref{quan4} pode ser parafraseada como: “Não é o caso que exista alguma moeda de 10 centavos no meu bolso.” Ela pode ser traduzida como $\enot\exists x(Px \eand Dx)$. Também pode ser parafraseada como: “Tudo o que está no meu bolso não é uma moeda de 10 centavos”, e então poderia ser traduzida como $\forall x(Px \eif \enot Dx)$. Mais uma vez, as duas traduções são logicamente equivalentes. Ambas são traduções corretas da sentença \ref{quan4}.

Agora podemos traduzir o argumento da p.~\pageref{willard1}, aquele que motivou a necessidade de quantificadores:
\begin{quote}
Willard é um lógico. Todos os lógicos usam chapéus engraçados.\\
\therefore\ Willard usa um chapéu engraçado.
\end{quote}

\begin{ekey}
\item[UD:] pessoas
\item[Lx:] $x$ é lógico.
\item[Fx:] $x$ usa um chapéu engraçado.
\item[w:] Willard
\end{ekey}

Traduzindo, obtemos:
\begin{earg}
\item[] $Lw$
\item[] $\forall x(Lx \eif Fx)$
\item[\therefore] $Fw$
\end{earg}

Essa tradução recupera exatamente a estrutura que havia sido perdida na tradução em SL, e esse é um argumento válido em QL.



\subsection{Predicados vazios}

Um predicado não precisa se aplicar a nenhum elemento do UD. Um predicado que não se aplica a nada no UD é chamado de \define{predicado vazio}.

Suponha que queiramos simbolizar as duas sentenças:
\begin{earg}
\item[\ex{monkey1}] Todo macaco sabe língua de sinais.
\item[\ex{monkey2}] Algum macaco sabe língua de sinais.
\end{earg}

É possível escrever a chave de simbolização dessas sentenças da seguinte forma:

\begin{ekey}
\item[UD:] animais
\item[Mx:] $x$ é um macaco.
\item[Sx:] $x$ sabe língua de sinais.
\end{ekey}

A sentença \ref{monkey1} pode ser traduzida como $\forall x(Mx \eif Sx)$.

A sentença \ref{monkey2} torna-se $\exists x(Mx \eand Sx)$.

É tentador dizer que \ref{monkey1} implica \ref{monkey2}; ou seja: se todo macaco sabe língua de sinais, então deve haver algum macaco que sabe língua de sinais. Essa é uma inferência válida na lógica aristotélica: Todos os $M$ são $S$, \therefore\ algum $M$ é $S$. Contudo, essa implicação não vale em QL. É possível que a sentença $\forall x(Mx \eif Sx)$ seja verdadeira mesmo quando a sentença $\exists x(Mx \eand Sx)$ seja falsa.

Como isso é possível? A resposta aparece quando consideramos se essas sentenças seriam verdadeiras ou falsas \emph{caso não houvesse macacos}.

Definimos $\forall$ e $\exists$ de modo que $\forall\script{A}$ seja equivalente a $\enot\exists\enot\script{A}$. Assim, o quantificador universal não envolve por si só a existência de coisa alguma — apenas a \emph{não-existência} de certos contraexemplos. Se \ref{monkey1} é verdadeira, isso significa que não há macacos que não saibam língua de sinais. Se não houvesse macacos, então $\forall x(Mx \eif Sx)$ seria verdadeira e $\exists x(Mx \eand Sx)$ seria falsa.

Permitimos predicados vazios porque queremos ser capazes de dizer coisas como: “Não sei se existem macacos, mas quaisquer macacos que existirem sabem língua de sinais.” Isto é, queremos poder trabalhar com predicados que não se aplicam (ou talvez não se apliquem) a nada.

O que acontece se adicionarmos um predicado vazio $R$ à interpretação acima? Por exemplo, podemos definir $Rx$ como “$x$ é uma geladeira”. Nesse caso, a sentença $\forall x(Rx \eif Mx)$ será verdadeira. Isso é contra-intuitivo, pois não queremos dizer que “todas as geladeiras são macacos”. É importante lembrar, porém, que $\forall x(Rx \eif Mx)$ significa que todo membro do UD que for uma geladeira é também um macaco. Como o UD é “animais”, não há geladeiras no UD, e por isso a sentença é trivialmente verdadeira.

Se você estivesse realmente traduzindo a frase “Toda geladeira é um macaco”, então deveria incluir eletrodomésticos no UD. Nesse novo UD, o predicado $R$ não seria vazio e a sentença $\forall x(Rx \eif Mx)$ seria falsa.

\begin{table}[h!]
\factoidbox{
\begin{itemize}
\item Um UD deve ter \emph{pelo menos} um membro.
\item Um predicado pode aplicar-se a alguns, a todos, ou a nenhum membro do UD.
\item Uma constante deve escolher \emph{exatamente} um membro do UD.

Um membro do UD pode ser escolhido por uma constante, por várias constantes, ou por nenhuma.
\end{itemize}
}
\end{table}


\subsection{Escolhendo um Universo de Discurso}

A simbolização adequada de uma sentença em língua natural em QL vai depender da chave de simbolização. Em certo sentido, isso é óbvio: importa saber se $Dx$ significa “$x$ é delicado” ou “$x$ é perigoso”. O significado das sentenças de QL também depende do UD.

Seja $Rx$ “$x$ é uma rosa”, seja $Tx$ “$x$ tem espinhos”, e considere a sentença:

\begin{earg}
\item[\ex{pickUDrose}] Toda rosa tem espinhos.
\end{earg}

É tentador dizer que \ref{pickUDrose} deve ser traduzida como $\forall x(Rx \eif Tx)$. Se o UD contém todas as rosas, essa tradução está correta. Mas se o UD for apenas “coisas em cima da minha mesa da cozinha”, então $\forall x(Rx \eif Tx)$ significará apenas que toda rosa em cima da minha mesa da cozinha tem espinhos. Se não houver rosas na mesa, a sentença será trivialmente verdadeira.

Como o quantificador universal só percorre os membros do UD, precisamos incluir todas as rosas no UD para traduzir \ref{pickUDrose}. Temos duas opções. Primeira: restringir o UD para incluir todas as rosas, mas \emph{apenas} rosas. Então \ref{pickUDrose} se traduz por $\forall x Tx$. Isso significa que tudo no UD tem espinhos; como o UD é justamente o conjunto de rosas, isso significa que toda rosa tem espinhos. Essa opção economiza trabalho se todas as sentenças que quisermos traduzir com essa chave forem sobre rosas.

Segunda opção: permitir que o UD contenha coisas além de rosas — como rododendros, ratos, rifles e o que mais quisermos. Nesse caso, \ref{pickUDrose} deve ser traduzida como $\forall x(Rx \eif Tx)$.

Se quiséssemos que o quantificador universal significasse “todas as coisas, sem restrição alguma”, talvez tentássemos especificar um UD que contivesse absolutamente tudo. Isso leva a problemas. “Tudo” inclui coisas apenas imaginadas, como personagens de ficção? Por um lado, queremos ser capazes de simbolizar argumentos sobre Hamlet ou Sherlock Holmes, e para isso precisamos ter a opção de incluir personagens fictícios no UD. Por outro lado, nunca precisamos falar sobre absolutamente todas as coisas que não existem — isso talvez nem faça sentido. Há questões filosóficas aqui que não vamos abordar. Podemos contornar essas dificuldades especificando sempre o UD. Por exemplo, se quisermos falar de plantas, pessoas e cidades, o UD pode ser “seres vivos e lugares”.

Suponha que queiramos traduzir a sentença \ref{pickUDrose} e, com a mesma chave, traduzir também estas sentenças:

\begin{earg}
\item[\ex{pickUDhair}] Esmerelda tem uma rosa no cabelo.
\item[\ex{pickUDcross}] Todo mundo está irritado com Esmerelda.
\end{earg}

Precisamos de um UD que inclua rosas (para simbolizar \ref{pickUDrose}) e pessoas (para simbolizar \ref{pickUDhair}–\ref{pickUDcross}). Eis uma chave adequada:

\begin{ekey}
\item[UD:] pessoas e plantas
\item[Px:] $x$ é uma pessoa.
\item[Rx:] $x$ é uma rosa.
\item[Tx:] $x$ tem espinhos.
\item[Cxy:] $x$ está irritado com $y$.
\item[Hxy:] $x$ tem $y$ no cabelo.
\item[e:] Esmerelda
\end{ekey}

Como não temos um predicado que signifique “$x$ tem uma rosa no cabelo”, a tradução de \ref{pickUDhair} exige uma paráfrase. A sentença diz que há uma rosa no cabelo de Esmerelda, isto é, existe algo que é uma rosa e que está no cabelo de Esmerelda. Assim, obtemos: $\exists x(Rx \eand Hex)$.

É tentador traduzir \ref{pickUDcross} como $\forall x Cxe$. Infelizmente, isso significaria que todo membro do UD está irritado com Esmerelda — pessoas \emph{e} plantas. Significaria, por exemplo, que a rosa no cabelo de Esmerelda está irritada com ela. E, é claro, \ref{pickUDcross} não quer dizer isso.

“Todo mundo” significa todas as pessoas, não todos os membros do UD. Então podemos parafrasear \ref{pickUDcross} como: “Toda pessoa está irritada com Esmerelda.” Sabemos simbolizar sentenças desse tipo: $\forall x(Px \eif Cxe)$.

Em geral, o quantificador universal pode ser usado para significar “todo mundo” se o UD contiver apenas pessoas. Se o UD incluir pessoas e outros tipos de coisas, então “todo mundo” deve ser tratado como “toda pessoa”.



\subsection{Tradução de pronomes}

Ao traduzir para QL, é importante compreender a estrutura das sentenças que queremos traduzir. O que importa é a tradução final em QL, e às vezes você conseguirá ir diretamente de uma frase em língua natural para uma fórmula em QL. Em outros casos, ajuda muito parafrasear a sentença uma ou mais vezes. Cada paráfrase sucessiva deve aproximar a sentença original de algo que você consiga traduzir diretamente para QL.

Nos próximos exemplos, usaremos a seguinte chave de simbolização:

\begin{ekey}
\item[UD:] pessoas
\item[Gx:] $x$ sabe tocar guitarra.
\item[Rx:] $x$ é uma estrela do rock.
\item[l:] Lemmy
\end{ekey}

Agora considere estas sentenças:

\begin{earg}
\item[\ex{pronoun1}] Se Lemmy sabe tocar guitarra, então ele é uma estrela do rock.
\item[\ex{pronoun2}] Se uma pessoa sabe tocar guitarra, então ela é uma estrela do rock.
\end{earg}

As sentenças \ref{pronoun1} e \ref{pronoun2} têm o mesmo consequente (“então ele/ela é uma estrela do rock”), mas não podem ser traduzidas da mesma forma. Ajuda bastante parafrasear as sentenças originais, substituindo os pronomes por referências explícitas.

A sentença \ref{pronoun1} pode ser parafraseada como: “Se Lemmy sabe tocar guitarra, então \emph{Lemmy} é uma estrela do rock.” Ela pode ser traduzida diretamente como $Gl \eif Rl$.

A sentença \ref{pronoun2} precisa ser parafraseada de modo diferente: “Se uma pessoa sabe tocar guitarra, então \emph{essa pessoa} é uma estrela do rock.” Essa sentença não fala de nenhuma pessoa específica; por isso precisamos de uma variável. Traduzindo “pela metade”, podemos parafrasear assim: “Para toda pessoa $x$, se $x$ sabe tocar guitarra, então $x$ é uma estrela do rock.” Agora podemos traduzi-la como $\forall x (Gx \eif Rx)$. Essa é apenas outra forma de dizer: “Todo mundo que sabe tocar guitarra é uma estrela do rock.”

Considere agora estas outras sentenças:

\begin{earg}
\item[\ex{anyone1}] Se alguém sabe tocar guitarra, então Lemmy sabe.
\item[\ex{anyone2}] Se alguém sabe tocar guitarra, então essa pessoa é uma estrela do rock.
\end{earg}

Essas duas sentenças têm o mesmo antecedente (“Se alguém sabe tocar guitarra$\ldots$”), mas estruturas lógicas diferentes.

A sentença \ref{anyone1} pode ser parafraseada como: “Se existe alguém que sabe tocar guitarra, então Lemmy sabe tocar guitarra.” O antecedente e o consequente são sentenças independentes, então podemos simbolizar isso como um condicional cujo conectivo principal é $\eif$: $\exists x Gx \eif Gl$.

A sentença \ref{anyone2} pode ser parafraseada como: “Para qualquer pessoa, se essa pessoa sabe tocar guitarra, então essa pessoa é uma estrela do rock.” Seria um erro simbolizá-la com um quantificador existencial, porque ela está falando de todos. A sentença é equivalente a “Todos que sabem tocar guitarra são estrelas do rock”. A melhor tradução é $\forall x(Gx \eif Rx)$.

As palavras “algum”, “qualquer” ou “alguém” em português (correspondendo a “any”, “anyone” em inglês) geralmente devem ser traduzidas usando quantificadores. Como os exemplos mostram, às vezes chamam um quantificador existencial (como em \ref{anyone1}) e às vezes um universal (como em \ref{anyone2}). Se for difícil decidir qual usar, tente parafrasear a frase usando outras palavras no lugar de “algum” ou “qualquer”, até que a estrutura lógica fique clara.



\subsection{Quantificadores e escopo}

Na sentença $\exists x Gx \eif Gl$, o escopo do quantificador existencial é a expressão $Gx$. Será que faz diferença se o escopo do quantificador for a sentença toda? Ou seja, a sentença $\exists x (Gx \eif Gl)$ tem um significado diferente?

Com a chave acima, $\exists x Gx \eif Gl$ significa: se existe algum guitarrista, então Lemmy é guitarrista. Já $\exists x (Gx \eif Gl)$ significaria que existe alguma pessoa tal que, se essa pessoa fosse guitarrista, então Lemmy seria guitarrista. Lembre que o condicional aqui é o condicional material; ele é verdadeiro se o antecedente é falso. Seja $p$ uma constante que denote o autor deste livro, alguém que certamente não é guitarrista. A sentença $Gp \eif Gl$ é verdadeira porque $Gp$ é falsa. Como existe uma pessoa (aquela denotada por $p$) que torna verdadeira essa sentença, $\exists x (Gx \eif Gl)$ é verdadeira. Em outras palavras, a sentença é verdadeira apenas porque existe alguém que não é guitarrista, independentemente da habilidade de Lemmy na guitarra.

Algo estranho acontece quando mudamos o escopo do quantificador, e isso está ligado ao fato de o condicional de QL ser um condicional material. Para manter o mesmo significado ao mudar o escopo, precisaríamos trocar o quantificador: $\exists x Gx \eif Gl$ significa o mesmo que $\forall x (Gx \eif Gl)$, e $\exists x (Gx \eif Gl)$ significa o mesmo que $\forall x Gx \eif Gl$.

Essa estranheza não aparece com outros conectivos nem quando a variável está no consequente do condicional. Por exemplo, $\exists x Gx \eand Gl$ significa a mesma coisa que $\exists x (Gx \eand Gl)$; e $Gl \eif \exists x Gx$ significa o mesmo que $\exists x(Gl \eif Gx)$.



\subsection{Predicados ambíguos}

Suponha que queiramos apenas traduzir a sentença:

\begin{earg}
\item[\ex{surgeon1}] Adina é uma cirurgiã competente.
\end{earg}

Tomemos o UD como “pessoas”, $Kx$ como “$x$ é uma cirurgiã competente” e $a$ como “Adina”. A sentença \ref{surgeon1} é simplesmente $Ka$.

Agora suponha que queiramos traduzir este argumento:

\begin{quote}
O hospital só contrata um cirurgião competente. Todos os cirurgiões são gananciosos. Billy é cirurgião, mas não é competente. Logo, Billy é ganancioso, mas o hospital não o contratará.
\end{quote}

Precisamos distinguir entre ser um \emph{cirurgião competente} e ser um \emph{cirurgião} simplesmente. Assim, definimos esta chave:

\begin{ekey}
\item[UD:] pessoas
\item[Gx:] $x$ é ganancioso.
\item[Hx:] o hospital contratará $x$.
\item[Rx:] $x$ é cirurgião.
\item[Kx:] $x$ é competente.
\item[b:] Billy
\end{ekey}

O argumento pode ser traduzido assim:

\begin{earg}
\label{surgeon2}
\item[] $\forall x\bigl[\enot (Rx \eand Kx) \eif \enot Hx\bigr]$
\item[] $\forall x(Rx \eif Gx)$
\item[] $Rb \eand \enot Kb$
\item[\therefore] $Gb \eand \enot Hb$
\end{earg}

Agora suponha que queiramos traduzir este outro argumento:

\begin{quote}
\label{surgeon3}
Carol é uma cirurgiã competente e joga tênis. Logo, Carol é uma jogadora de tênis competente.
\end{quote}

Se começarmos com a chave de simbolização que usamos no argumento anterior, podemos acrescentar um predicado (seja $Tx$ “$x$ joga tênis”) e uma constante (seja $c$ “Carol”). O argumento ficaria:

\begin{earg}
\item[] $(Rc \eand Kc) \eand Tc$
\item[\therefore] $Tc \eand Kc$
\end{earg}

Essa tradução é um desastre! Ela transforma um argumento claramente ruim em língua natural em um argumento válido em QL. O problema é que há uma diferença entre ser \emph{competente como cirurgiã} e \emph{competente como jogadora de tênis}. Traduzir corretamente exige dois predicados distintos, um para cada tipo de competência. Se deixarmos $K_1x$ significar “$x$ é competente como cirurgiã” e $K_2x$ significar “$x$ é competente como jogadora de tênis”, podemos simbolizar o argumento assim:

\begin{earg}
\label{surgeon3correct}
\item[] $(Rc \eand K_1c) \eand Tc$
\item[\therefore] $Tc \eand K_2c$
\end{earg}

Assim como o argumento original em português, esse é inválido. 

A moral desses exemplos é que precisamos ter cuidado para não simbolizar predicados de forma ambígua. Problemas semelhantes surgem com predicados como \emph{bom}, \emph{mau}, \emph{grande} e \emph{pequeno}. Assim como cirurgiões competentes e jogadoras de tênis competentes têm competências diferentes, cães grandes, ratos grandes e problemas grandes são “grandes” de maneiras distintas.

É suficiente ter um predicado que signifique “$x$ é uma cirurgiã competente”, em vez de dois predicados separados “$x$ é competente” e “$x$ é cirurgiã”? Às vezes, sim. Como mostra a sentença \ref{surgeon1}, nem sempre precisamos distinguir entre cirurgiões competentes e outros cirurgiões.

Precisamos sempre distinguir entre modos diferentes de ser competente, bom, mau ou grande? Não. Como o argumento sobre Billy mostra, às vezes só precisamos falar de um tipo de competência. Se você estiver traduzindo um argumento que trata apenas de cães, pode definir um predicado que signifique simplesmente “$x$ é grande”. Se o UD incluir cães e ratos, porém, provavelmente é melhor entender o predicado como “$x$ é grande para um cão”.



\subsection{Múltiplos quantificadores}

Considere a seguinte chave de simbolização e as sentenças que se seguem:

\begin{ekey}
\item[UD:] pessoas e cães
\item[Dx:] $x$ é um cão.
\item[Fxy:] $x$ é amigo de $y$.
\item[Oxy:] $x$ é dono de $y$.
\item[f:] Fifi
\item[g:] Geraldo
\end{ekey}

\begin{earg}
\item[\ex{dog1}] Fifi é um cão.
\item[\ex{dog2}] Geraldo é dono de um cão.
\item[\ex{dog3}] Alguém é dono de um cão.
\item[\ex{dog4}] Todos os amigos de Geraldo são donos de cães.
\item[\ex{dog5}] Todo dono de cão é amigo de algum dono de cão.
\end{earg}

A sentença \ref{dog1} é simples: $Df$.

A sentença \ref{dog2} pode ser parafraseada como: “Existe um cão do qual Geraldo é dono.” Ela pode ser traduzida como $\exists x(Dx \eand Ogx)$.

A sentença \ref{dog3} pode ser parafraseada como: “Existe algum $y$ tal que $y$ é dono de um cão.” A subsentença “$y$ é dono de um cão” tem a mesma estrutura de \ref{dog2}, exceto por ser sobre $y$ em vez de ser sobre Geraldo. Assim, podemos traduzir \ref{dog3} como $\exists y \exists x(Dx \eand Oyx)$. 
%(Podemos trocar $x$ e $y$, mas é importante usar duas variáveis diferentes.)

A sentença \ref{dog4} pode ser parafraseada como: “Todo amigo de Geraldo é dono de cão.” Traduzindo parte dessa sentença, obtemos $\forall x(Fxg \eif \text{“$x$ é dono de cão”})$. É importante notar que “$x$ é dono de cão” tem a mesma estrutura de \ref{dog2}. Como já temos um quantificador sobre $x$, precisaremos de outra variável para o quantificador existencial. Qualquer outra serve. Usando $z$, \ref{dog4} pode ser traduzida como $\forall x\bigl[Fxg \eif\exists z(Dz \eand Oxz)\bigr]$.

A sentença \ref{dog5} pode ser parafraseada como: “Para qualquer $x$ que seja dono de cão, existe um dono de cão que é amigo de $x$.” Parcialmente traduzida, fica assim:
$$\forall x\bigl[\text{“$x$ é dono de cão”} \eif \exists y(\text{“$y$ é dono de cão”} \eand Fxy)\bigr].$$
Completando a tradução, \ref{dog5} torna-se
$$\forall x\bigl[\exists z(Dz \eand Oxz) \eif \exists y\bigl(\exists z(Dz \eand Oyz) \eand Fxy\bigr)\bigr].$$

Considere agora esta chave e estas sentenças:

\begin{ekey}
\item[UD:] pessoas
\item[Lxy:] $x$ gosta de $y$.
\item[i:] Imre
\item[k:] Karl
\end{ekey}

\begin{earg}
\item[\ex{likes1}] Imre gosta de todo mundo de quem Karl gosta.
\item[\ex{likes2}] Existe alguém que gosta de todo mundo que gosta de todo mundo de quem essa pessoa gosta.
\end{earg}

A sentença \ref{likes1} pode ser parcialmente traduzida como $\forall x(\text{“Karl gosta de $x$”} \eif \text{“Imre gosta de $x$”})$. Isso se torna $\forall x(Lkx \eif Lix)$.

A sentença \ref{likes2} é quase um trava-línguas. Não há muita esperança de escrever a tradução completa de uma vez, mas podemos proceder em pequenos passos. Uma tradução inicial e parcial pode ser:

$$\exists x\ \text{todo mundo que gosta de todo mundo de quem $x$ gosta é alguém de quem $x$ gosta.}$$

A parte que ainda está em português é uma sentença universal, então traduzimos mais um pouco:

$$\exists x\forall y(\text{“$y$ gosta de todo mundo de quem $x$ gosta”} \eif \text{“$x$ gosta de $y$”}).$$

O antecedente do condicional tem a mesma estrutura lógica da sentença \ref{likes1}, só que com $y$ e $x$ no lugar de Imre e Karl. Assim, \ref{likes2} pode ser traduzida completamente como:

$$\exists x\forall y\bigl[\forall z(Lxz \eif Lyz) \eif Lxy\bigr].$$

Ao simbolizar sentenças com múltiplos quantificadores, o melhor caminho é avançar por pequenos passos. Parafraseie a sentença em língua natural até que a estrutura lógica fique clara o suficiente. Depois, traduza por partes, substituindo a tarefa intimidadora de traduzir uma frase longa pela tarefa mais simples de traduzir pequenas fórmulas intermediárias.



\section{Sentenças em QL}

Nesta seção, fornecemos uma definição formal de \emph{fórmula bem-formada} (fbf) e de \emph{sentença} de QL.

\subsection{Expressões}

Há seis tipos de símbolos em QL:

\begin{center}
\begin{tabular}{|c|c|}
\hline
predicados & $A,B,C,\ldots,Z$\\
com índices, se necessário & $A_1, B_1,Z_1,A_2,A_{25},J_{375},\ldots$\\
\hline
constantes & $a,b,c,\ldots,w$\\
com índices, se necessário & $a_1, w_4, h_7, m_{32},\ldots$\\
\hline
variáveis & $x,y,z$\\
com índices, se necessário & $x_1, y_1, z_1, x_2,\ldots$\\
\hline
conectivos & \enot,\eand,\eor,\eif,\eiff\\
\hline
parênteses & ( , )\\
\hline
quantificadores & $\forall, \exists$\\
\hline
\end{tabular}
\end{center}

Definimos uma \define{expressão de QL} como qualquer cadeia de símbolos de QL. Pegue quaisquer símbolos de QL e escreva-os em qualquer ordem: o resultado será uma expressão de QL. Nada garante, porém, que essa expressão tenha uma estrutura lógica bem formada.



\subsection{Fórmulas bem-formadas}

Por definição, um \define{termo de QL} é ou uma constante ou uma variável.

Uma \define{fórmula atômica de QL} é um predicado $n$-ádico seguido de $n$ termos.

Assim como fizemos em SL, daremos uma definição \emph{recursiva} de fbf de QL. De fato, grande parte da definição será semelhante à definição de fbf para SL: toda fórmula atômica é uma fbf, e podemos construir novas fbfs aplicando os conectivos verofuncionais.

Poderíamos simplesmente acrescentar uma regra para cada quantificador e encerrar o assunto. Por exemplo: se $\script{A}$ é uma fbf, então $\forall x\script{A}$ e $\exists x\script{A}$ são fbfs. Porém, isso permitiria fórmulas estranhas como $\forall x\exists x Dx$ e $\forall x Dw$. O que essas expressões deveriam significar? Até poderíamos tentar interpretá-las, mas preferimos escrever a definição de fbf de modo que tais “aberrações” nem mesmo contem como bem-formadas.

Para que $\forall x\script{A}$ seja uma fbf, $\script{A}$ deve conter a variável $x$ e não deve já conter um quantificador-$x$. A expressão $\forall x Dw$ não será considerada fbf porque `$x$' não ocorre em $Dw$, e $\forall x \exists x Dx$ não será uma fbf porque $\exists x Dx$ já contém um quantificador-$x$.

A definição completa de \emph{fórmula bem-formada de QL} é a seguinte:

\begin{enumerate}
\item Toda fórmula atômica é uma fbf.
\item Se $\script{A}$ é uma fbf, então $\enot\script{A}$ é uma fbf.
\item Se $\script{A}$ e $\script{B}$ são fbfs, então $(\script{A}\eand\script{B})$ é uma fbf.
\item Se $\script{A}$ e $\script{B}$ são fbfs, então $(\script{A}\eor\script{B})$ é uma fbf.
\item Se $\script{A}$ e $\script{B}$ são fbfs, então $(\script{A}\eif\script{B})$ é uma fbf.
\item Se $\script{A}$ e $\script{B}$ são fbfs, então $(\script{A}\eiff\script{B})$ é uma fbf.
\item Se $\script{A}$ é uma fbf, $\script{x}$ é uma variável, $\script{A}$ contém pelo menos uma ocorrência de $\script{x}$ e $\script{A}$ não contém quantificadores-$\script{x}$, então $\forall\script{x}\script{A}$ é uma fbf.
\item Se $\script{A}$ é uma fbf, $\script{x}$ é uma variável, $\script{A}$ contém pelo menos uma ocorrência de $\script{x}$ e $\script{A}$ não contém quantificadores-$\script{x}$, então $\exists\script{x}\script{A}$ é uma fbf.
\item Todas e somente as fbfs de QL podem ser geradas por aplicações finitas dessas regras.
\end{enumerate}

Note que o `\script{x}' que aparece na definição acima não é a variável específica $x$ de QL. Trata-se de uma \emph{meta-variável} que representa qualquer variável da linguagem (como $x$, $y$, $z$, $x_1$ etc.). Assim, $\forall xAx$ é uma fbf, mas também o são $\forall yAy$, $\forall zAz$, $\forall x_4Ax_4$ e $\forall z_9Az_9$.

Podemos agora dar uma definição formal de \emph{escopo}: o \define{escopo} de um quantificador é a subfórmula para a qual esse quantificador é o operador lógico principal. 



\subsection{Sentenças}

Uma \define{sentença} é algo que pode ser verdadeiro ou falso. Em SL, toda fbf era uma sentença. Em QL isso já não vale. Considere a seguinte chave de simbolização:

\begin{ekey}
\item[UD:] pessoas
\item[Lxy:] $x$ ama $y$
\item[b:] Boris
\end{ekey}

Considere a expressão $Lzz$. Trata-se de uma fórmula atômica: um predicado binário seguido de dois termos. Toda fórmula atômica é uma fbf, então $Lzz$ é fbf. Mas essa expressão “diz” alguma coisa? Você poderia achar que ela significa que $z$ ama a si mesmo, do mesmo modo que $Lbb$ significa que Boris ama a si mesmo. No entanto, $z$ é uma variável; ela não nomeia uma pessoa específica, como faz uma constante. A fbf $Lzz$ não nos diz como interpretar $z$. Ela não nos informa se se trata de “todo mundo”, “alguém”, “ninguém” ou “exatamente uma pessoa”. Se tivéssemos um quantificador-$z$, ele nos diria como interpretar $z$. Por exemplo, $\exists zLzz$ significaria que alguém ama a si mesmo.

Algumas linguagens formais tratam uma fbf como $Lzz$ como se houvesse um quantificador universal implícito na frente da fórmula. Não faremos isso em QL. Se você quer dizer que “todo mundo ama a si mesmo”, precisa escrever explicitamente o quantificador: $\forall zLzz$.

Para dar sentido a uma variável, precisamos de um quantificador que nos diga como interpretá-la. O escopo de um quantificador-$x$, por exemplo, é a parte da fórmula em que o quantificador diz como devemos entender $x$.

Para ser mais preciso, definimos uma \define{ocorrência ligada} de uma variável $\script{x}$ como uma ocorrência de $\script{x}$ que está dentro do escopo de algum quantificador-$\script{x}$. Uma \define{ocorrência livre} de $\script{x}$ é uma ocorrência que não está ligada a nenhum quantificador-$\script{x}$.

Por exemplo, considere a fbf
\[
\forall x(Ex \eor Dy) \eif \exists z(Ex \eif Lzx).
\]
O escopo do quantificador universal $\forall x$ é $(Ex \eor Dy)$, de modo que a primeira ocorrência de $x$ está ligada por esse quantificador, mas as outras ocorrências de $x$ (na parte $\exists z(Ex \eif Lzx)$) são livres. Não há quantificador-$y$, então o $y$ é livre. O escopo do quantificador existencial $\exists z$ é $(Ex \eif Lzx)$, e assim ambas as ocorrências de $z$ nessa subfórmula estão ligadas por ele.

Podemos então definir:

\begin{quote}
Uma \define{sentença} de QL é uma fbf de QL que não contém variáveis livres.
\end{quote}



\subsection{Convenções notacionais}

Adotaremos as mesmas convenções notacionais que utilizamos em SL (p.~\pageref{SLconventions}). Em resumo:

\begin{itemize}
\item Podemos omitir os parênteses mais externos de uma fórmula.
\item Podemos usar colchetes `[' e `]' em lugar de parênteses para tornar algumas fórmulas mais legíveis.
\item Em séries de conjunções, podemos omitir parênteses entre cada par de conjunções, entendendo que a associação é feita à esquerda ou é irrelevante (quando não há ambiguidade).
\item O mesmo vale para longas séries de disjunções.
\end{itemize}

Essas convenções não alteram a gramática formal de QL; elas apenas nos permitem escrever fbfs de maneira mais compacta e amigável à leitura.


\section{Identidade}
\label{sec.identity}

Considere a seguinte sentença:
\begin{earg}
\item[\ex{else1}] Pavel deve dinheiro a todo mundo menos a ele mesmo.
\end{earg}
Vamos tomar como UD (universo de discurso) as pessoas; isso nos permite traduzir “todo mundo” com um quantificador universal. Seja $Oxy$ “$x$ deve dinheiro a $y$” e seja $p$ “Pavel”. Assim, poderíamos simbolizar a sentença \ref{else1} como $\forall x\,Opx$.

Infelizmente, essa tradução tem uma consequência estranha: ela diz que Pavel deve dinheiro a todo membro da UD, inclusive ao próprio Pavel; isto é, ela implica que Pavel deve dinheiro a si mesmo. Mas a sentença \ref{else1} não diz que Pavel deve dinheiro a si próprio; ela diz que ele deve dinheiro a todo mundo \emph{exceto ele}. Este é um problema, porque $\forall x\,Opx$ é a melhor tradução que conseguimos dar para essa frase em QL, com os recursos que tínhamos até aqui.

A solução é acrescentar um novo símbolo a QL. O símbolo `$=$' será tratado como um predicado binário especial. Como ele tem um papel lógico diferenciado, escrevemo-o de modo um pouco distinto: dados dois termos $t_1$ e $t_2$, $t_1 = t_2$ é uma fórmula atômica.

O predicado $x = y$ significa “$x$ é idêntico a $y$”. Isso não quer dizer apenas que $x$ e $y$ são indistinguíveis ou que todos os mesmos predicados são verdadeiros de ambos; significa que $x$ e $y$ são \emph{o mesmo objeto}.

Quando escrevemos $x \neq y$, queremos dizer que $x$ e $y$ não são idênticos. Não há necessidade de introduzir um predicado novo para isso. Em vez disso, $x \neq y$ é apenas uma abreviatura para $\enot(x = y)$.

Suponha agora que queiramos simbolizar a seguinte sentença:
\begin{earg}
\item[\ex{else2}] Pavel é o senhor Checkov.
\end{earg}
Seja a constante $c$ “senhor Checkov”. A sentença \ref{else2} pode ser simbolizada como $p = c$. Isso significa que as constantes $p$ e $c$ se referem ao mesmo indivíduo.

Até aqui, tudo bem — mas como isso ajuda com a sentença \ref{else1}? Essa sentença pode ser parafraseada como: “Todo mundo que não é Pavel é alguém a quem Pavel deve dinheiro”. Esse é um tipo de estrutura frasal que já sabemos simbolizar: “Para todo $x$, se $x$ não é Pavel, então Pavel deve dinheiro a $x$”. Em QL com identidade, isso se torna:
\[
\forall x(x \neq p \eif Opx).
\]

Além de sentenças que usam a palavra “exceto”, a identidade será útil na simbolização de sentenças com palavras como “além de” e “apenas”. Considere, por exemplo:

\begin{earg}
\item[\ex{else3}] Ninguém além de Pavel deve dinheiro a Hikaru.
\item[\ex{else4}] Só Pavel deve dinheiro a Hikaru.
\end{earg}

Introduzamos a constante $h$, que significa Hikaru.

A sentença \ref{else3} pode ser parafraseada como: “Ninguém que seja diferente de Pavel deve dinheiro a Hikaru”. Isso pode ser traduzido como:
\[
\enot\exists x(x \neq p \eand Oxh).
\]

A sentença \ref{else4} pode ser parafraseada como: “Pavel deve dinheiro a Hikaru \emph{e} ninguém além de Pavel deve dinheiro a Hikaru”. Já traduzimos uma das conjunções; a outra é direta. Assim, \ref{else4} torna-se:
\[
Oph \eand \enot\exists x(x \neq p \eand Oxh).
\]


\subsection{Expressões de quantidade}

Também podemos usar identidade para dizer quantos objetos de determinado tipo existem. Por exemplo, considere estas sentenças:
\begin{earg}
\item[\ex{atleast1}] Há pelo menos uma maçã sobre a mesa.
\item[\ex{atleast2}] Há pelo menos duas maçãs sobre a mesa.
\item[\ex{atleast3}] Há pelo menos três maçãs sobre a mesa.
\end{earg}
Tome a UD como \emph{coisas sobre a mesa} e seja $Ax$ “$x$ é uma maçã”.

A sentença \ref{atleast1} não exige identidade. Ela pode ser traduzida adequadamente como $\exists x Ax$: existe alguma maçã sobre a mesa — talvez muitas, mas ao menos uma.

Pode ser tentador tentar traduzir também \ref{atleast2} sem identidade. Mas veja a fórmula $\exists x \exists y(Ax \eand Ay)$. Ela significa que existe uma maçã $x$ na UD e uma maçã $y$ na UD. Como nada impede que $x$ e $y$ designem o mesmo elemento, essa fórmula seria verdadeira mesmo que houvesse apenas uma maçã. Para garantir que existam duas maçãs \emph{diferentes}, precisamos do predicado de identidade. A sentença \ref{atleast2} precisa afirmar que as duas maçãs existentes não são idênticas; assim, pode ser traduzida como:
\[
\exists x \exists y(Ax \eand Ay \eand x \neq y).
\]

A sentença \ref{atleast3} exige falar de três maçãs diferentes. Uma tradução adequada é:
\[
\exists x \exists y \exists z(Ax \eand Ay \eand Az \eand x \neq y \eand y \neq z \eand x \neq z).
\]

Prosseguindo dessa forma, poderíamos traduzir “Há pelo menos $n$ maçãs sobre a mesa” para qualquer número $n$. (Um resumo de como simbolizar esse tipo de expressão aparece em p.~\pageref{summary.atleast}.)

Agora observe as sentenças:
\begin{earg}
\item[\ex{atmost1}] Há no máximo uma maçã sobre a mesa.
\item[\ex{atmost2}] Há no máximo duas maçãs sobre a mesa.
\end{earg}

A sentença \ref{atmost1} pode ser parafraseada como: “Não é o caso que haja \emph{duas} ou mais maçãs sobre a mesa”. Isso é apenas a negação de \ref{atleast2}:
\[
\enot \exists x \exists y(Ax \eand Ay \eand x \neq y).
\]
A sentença \ref{atmost1} também pode ser abordada de outro modo. Ela diz que quaisquer maçãs que estejam sobre a mesa têm de ser, na verdade, a \emph{mesma} maçã; assim, pode ser traduzida como:
\[
\forall x \forall y\bigl[(Ax \eand Ay) \eif x = y\bigr].
\]
As duas traduções são logicamente equivalentes; logo, ambas estão corretas.

De maneira análoga, \ref{atmost2} pode ser traduzida de duas formas equivalentes. Podemos paráfraseá-la como “Não é o caso que haja \emph{três} ou mais maçãs distintas”, isto é, como a negação de \ref{atleast3}. Usando quantificadores universais, podemos também escrevê-la como:
\[
\forall x \forall y \forall z\bigl[(Ax \eand Ay \eand Az) \eif (x = y \eor x = z \eor y = z)\bigr].
\]
(Ver p.~\pageref{summary.atmost} para o caso geral.)

Os exemplos acima são sobre maçãs, mas a estrutura lógica que eles exibem é a mesma de desigualdades numéricas como $a \geq 3$, $a \leq 2$ e assim por diante. Também queremos poder traduzir afirmações de \emph{igualdade} numérica: dizer exatamente quantos objetos há. Por exemplo:
\begin{earg}
\item[\ex{exactly1}] Há exatamente uma maçã sobre a mesa.
\item[\ex{exactly2}] Há exatamente duas maçãs sobre a mesa.
\end{earg}

A sentença \ref{exactly1} pode ser parafraseada como: “Há \emph{ao menos} uma maçã sobre a mesa, e há \emph{no máximo} uma maçã sobre a mesa”. Isto é, ela é a conjunção de \ref{atleast1} com \ref{atmost1}:
\[
\exists x Ax \eand \forall x \forall y\bigl[(Ax \eand Ay) \eif x = y\bigr].
\]
Esse é um modo um pouco trabalhoso de proceder. Talvez seja mais direto parafrasear \ref{exactly1} como: “Existe um objeto que é a única maçã sobre a mesa”. Pensando assim, podemos traduzir como:
\[
\exists x\bigl[Ax \eand \enot\exists y(Ay \eand x \neq y)\bigr].
\]

Analogamente, a sentença \ref{exactly2} pode ser parafraseada como: “Existem duas maçãs diferentes sobre a mesa, e estas são as únicas maçãs sobre a mesa”. Uma tradução é:
\[
\exists x \exists y\bigl[Ax \eand Ay \eand x \neq y \eand \enot\exists z(Az \eand x \neq z \eand y \neq z)\bigr].
\]

Por fim, considere:
\begin{earg}
\item[\ex{atmost2inUD}] Há no máximo duas coisas sobre a mesa.
\end{earg}
Pode ser tentador acrescentar um predicado $Tx$ significando “$x$ é uma coisa sobre a mesa”. Mas isso é desnecessário. Como a UD já é o conjunto das coisas sobre a mesa, todo membro da UD está sobre a mesa. Se queremos falar de “uma coisa sobre a mesa”, basta usar um quantificador. A sentença \ref{atmost2inUD} pode ser simbolizada como fizemos com \ref{atmost2} (que dizia que há no máximo duas maçãs), mas simplesmente omitindo o predicado. Isto é, \ref{atmost2inUD} pode ser traduzida como:
\[
\forall x \forall y \forall z(x = y \eor x = z \eor y = z).
\]

As técnicas para simbolizar expressões de quantidade (“no máximo”, “pelo menos” e “exatamente”) são resumidas em p.~\pageref{summary.atleast}.



\subsection{Descrições definidas}
\label{subsec.defdesc}

Lembre que uma constante de QL deve referir-se a algum membro da UD. Essa exigência nos permite evitar o problema dos termos sem referência. Se a UD incluir apenas criaturas realmente existentes, mas tivermos uma constante $c$ que signifique “quimera” (uma criatura mítica), sentenças contendo $c$ se tornarão impossíveis de avaliar.

A solução mais influente para esse problema foi proposta por Bertrand Russell em 1905. Russell perguntou como deveríamos entender a sentença:
\begin{earg}
\item[\ex{defdesc1}] O atual rei da França é careca.
\end{earg}
A expressão “o atual rei da França” deveria selecionar um indivíduo por meio de uma descrição definida. Contudo, não havia rei da França em 1905 — e não há hoje. Como a descrição é um termo sem referência, não podemos simplesmente definir uma constante para significar “o atual rei da França” e traduzir a sentença como $Kf$.

A ideia de Russell é que sentenças contendo descrições definidas têm uma estrutura lógica diferente de sentenças contendo nomes próprios, mesmo quando ambas compartilham a mesma forma gramatical. O que queremos dizer quando usamos uma descrição bem-comportada, como “o pico mais alto do estado de Washington”? Em primeiro lugar, queremos dizer que existe tal pico; caso contrário, não estaríamos conseguindo “apontar” nada. Em segundo lugar, queremos dizer que existe \emph{apenas um} pico com essa propriedade — se houvesse dois picos exatamente da mesma altura, aquele não seria \emph{o} mais alto.

Segundo essa análise, a sentença \ref{defdesc1} está dizendo três coisas. Primeiro, faz uma afirmação de \emph{existência}: existe um atual rei da França. Segundo, faz uma afirmação de \emph{unicidade}: esse indivíduo é o único atual rei da França. Terceiro, faz uma afirmação de \emph{predicação}: esse indivíduo é careca.

Para simbolizar descrições definidas desse modo, precisamos do predicado de identidade; sem ele, não poderíamos traduzir a afirmação de unicidade que (segundo Russell) está implicada na descrição definida.

Seja a UD “pessoas atualmente vivas”, seja $Fx$ “$x$ é o atual rei da França” e seja $Bx$ “$x$ é careca”. A sentença \ref{defdesc1} pode ser traduzida como:
\[
\exists x\bigl[Fx \eand \enot\exists y(Fy \eand x \neq y) \eand Bx\bigr].
\]
Isso diz que existe um indivíduo que é o atual rei da França, que ele é o único atual rei da França e que ele é careca.

Entendida assim, \ref{defdesc1} é significativa, mas falsa: ela afirma que tal indivíduo existe, mas ele não existe.

O problema dos termos sem referência fica mais delicado quando tentamos traduzir negações. Considere, portanto, a sentença:
\begin{earg}
\item[\ex{defdesc2}] O atual rei da França não é careca.
\end{earg}
De acordo com Russell, essa sentença é ambígua em inglês (e também em português). Ela pode significar duas coisas diferentes:
\begin{earg}
\item[\ref{defdesc2}a.] Não é o caso que o atual rei da França seja careca.
\item[\ref{defdesc2}b.] O atual rei da França é não-careca.
\end{earg}
Ambas negam \ref{defdesc1}, mas colocam a negação em lugares diferentes.

A sentença \ref{defdesc2}a é chamada de \define{negação de escopo amplo}, porque nega a sentença inteira. Ela pode ser traduzida como:
\[
\enot\exists x\bigl[Fx \eand \enot\exists y(Fy \eand x \neq y) \eand Bx\bigr].
\]
Essa fórmula não afirma nada diretamente sobre o atual rei da França; ela diz que uma \emph{certa sentença sobre} o atual rei da França é falsa. Como \ref{defdesc1} é falsa, \ref{defdesc2}a é verdadeira.

Já \ref{defdesc2}b afirma algo sobre o atual rei da França: ela diz que ele não possui a propriedade de ser careca. Como em \ref{defdesc1}, há uma afirmação de existência e de unicidade, mas agora a predicação é negada. Essa é a chamada \define{negação de escopo estreito}, que pode ser traduzida como:
\[
\exists x\bigl[Fx \eand \enot\exists y(Fy \eand x \neq y) \eand \enot Bx\bigr].
\]
Como não há atual rei da França, essa sentença é falsa.

A teoria das descrições definidas de Russell resolve o problema dos termos sem referência e também explica por que o problema parecia tão paradoxal. Antes de distinguirmos entre negação de escopo amplo e de escopo estreito, parecia que sentenças como \ref{defdesc2} deveriam ser ao mesmo tempo verdadeiras e falsas. Ao mostrar que tais sentenças são ambíguas, Russell mostra que elas são verdadeiras em um dos sentidos possíveis, mas falsas em outro.

Para uma discussão mais detalhada da teoria das descrições definidas de Russell, incluindo objeções a ela, veja a entrada “descriptions”, de Peter Ludlow, na \emph{Stanford Encyclopedia of Philosophy}: edição de verão de 2005, editada por Edward N. Zalta, disponível em \url{http://plato.stanford.edu/archives/sum2005/entries/descriptions/}


%\fix{glossary?}
%variável livre
%variável ligada
%escopo

\practiceproblems

%\solutions
%\problempart
%\label{pr.wiffQL}
%Para cada uma das fórmulas a seguir: (a) ela é uma fbf (wff) de QL, admitindo as convenções notacionais? (b) ela é uma sentença de QL?
%\begin{earg}
%\item $\forall x\forall y[(Rxy \eand Ryx) \eif \exists zRzz]$
%\end{earg}
%
%
%
%\problempart
%\begin{earg}
%\item Existem fbfs de QL que contêm mais de um quantificador-$x$? Se sua resposta for “sim”, dê um exemplo.
%\end{earg}


\solutions
\problempart
\label{pr.QLalligators}
Usando o quadro de simbolização a seguir, traduza cada sentença da língua natural para QL.
\begin{ekey}
\item[UD:] todos os animais
\item[Ax:] $x$ é um jacaré.
\item[Mx:] $x$ é um macaco.
\item[Rx:] $x$ é um réptil.
\item[Zx:] $x$ vive no zoológico.
\item[Lxy:] $x$ ama $y$.
\item[a:] Amos
\item[b:] Bouncer
\item[c:] Cleo
\end{ekey}
\begin{earg}
\item Amos, Bouncer e Cleo vivem todos no zoológico.
\item Bouncer é um réptil, mas não é um jacaré.
\item Se Cleo ama Bouncer, então Bouncer é um macaco.
\item Se tanto Bouncer quanto Cleo são jacarés, então Amos ama ambos.
\item Algum réptil vive no zoológico.
\item Todo jacaré é um réptil.
\item Qualquer animal que vive no zoológico é ou um macaco ou um jacaré.
\item Há répteis que não são jacarés.
\item Cleo ama um réptil.
\item Bouncer ama todos os macacos que vivem no zoológico.
\item Todos os macacos que Amos ama o amam de volta.
\item Se algum animal é um réptil, então Amos é um réptil.
\item Se algum animal é um jacaré, então ele é um réptil.
\item Todo macaco que Cleo ama também é amado por Amos.
\item Existe um macaco que ama Bouncer, mas infelizmente Bouncer não corresponde a esse amor.
\end{earg}



\problempart
\label{pr.BarbaraEtc}
Estas são figuras silogísticas identificadas por Aristóteles e seus sucessores, com seus nomes medievais. Traduza cada argumento para QL.
\begin{description}
\item[Barbara] Todos os $B$s são $C$s. Todos os $A$s são $B$s.\\
	\therefore\  Todos os $A$s são $C$s.
\item[Baroco] Todos os $C$s são $B$s. Algum $A$ não é $B$.\\
	\therefore\  Algum $A$ não é $C$.
\item[Bocardo] Algum $B$ não é $C$. Todos os $A$s são $B$s.\\
	\therefore\  Algum $A$ não é $C$.
\item[Celantes] Nenhum $B$ é $C$. Todos os $A$s são $B$s.\\
	\therefore\  Nenhum $C$ é $A$.
\item[Celarent] Nenhum $B$ é $C$. Todos os $A$s são $B$s.\\
	\therefore\  Nenhum $A$ é $C$.
\item[Cemestres] Nenhum $C$ é $B$. Nenhum $A$ é $B$.\\
	\therefore\  Nenhum $A$ é $C$.
\item[Cesare] Nenhum $C$ é $B$. Todos os $A$s são $B$s.\\
	\therefore\  Nenhum $A$ é $C$.
\item[Dabitis] Todos os $B$s são $C$s. Algum $A$ é $B$.\\
	\therefore\  Algum $C$ é $A$.
\item[Darii] Todos os $B$s são $C$s. Algum $A$ é $B$.\\
	\therefore\  Algum $A$ é $C$.
\item[Datisi] Todos os $B$s são $C$s. Todos os $A$s são $C$s.\\
	\therefore\  Algum $A$ é $C$.
\item[Disamis] Algum $A$ é $B$. Todos os $A$s são $C$s.\\
	\therefore\  Algum $B$ é $C$.
\item[Ferison] Nenhum $B$ é $C$. Algum $A$ é $B$.\\
	\therefore\  Algum $A$ não é $C$.
\item[Ferio] Nenhum $B$ é $C$. Algum $A$ é $B$.\\
	\therefore\  Algum $A$ não é $C$.
\item[Festino] Nenhum $C$ é $B$. Algum $A$ é $B$.\\
	\therefore\  Algum $A$ não é $C$.
\item[Baralipton] Todos os $B$s são $C$s. Todos os $A$s são $B$s.\\
	\therefore\  Algum $C$ é $A$.
\item[Frisesomorum] Algum $B$ é $C$. Nenhum $A$ é $B$.\\
	\therefore\  Algum $C$ não é $A$.
\end{description}



\problempart Usando o quadro de simbolização abaixo, traduza cada sentença da língua natural para QL.
\begin{ekey}
\item[UD:] todos os animais
\item[Dx:] $x$ é um cachorro.
\item[Sx:] $x$ gosta de filmes de samurai.
\item[Lxy:] $x$ é maior que $y$.
\item[b:] Bertie
\item[e:] Emerson
\item[f:] Fergis
\end{ekey}
\begin{earg}
\item Bertie é um cachorro que gosta de filmes de samurai.
\item Bertie, Emerson e Fergis são todos cachorros.
\item Emerson é maior que Bertie, e Fergis é maior que Emerson.
\item Todos os cachorros gostam de filmes de samurai.
\item Só cachorros gostam de filmes de samurai.
\item Existe um cachorro que é maior que Emerson.
\item Se existe um cachorro maior que Fergis, então existe um cachorro maior que Emerson.
\item Nenhum animal que goste de filmes de samurai é maior que Emerson.
\item Nenhum cachorro é maior que Fergis.
\item Qualquer animal que não gosta de filmes de samurai é maior que Bertie.
\item Existe um animal que está entre Bertie e Emerson em tamanho.
\item Não existe cachorro que esteja entre Bertie e Emerson em tamanho.
\item Nenhum cachorro é maior que ele mesmo.
\item Para todo cachorro, existe algum cachorro maior do que ele.
\item Existe um animal que é menor que todo cachorro.
\item Se existir um animal que é maior do que qualquer cachorro, então esse animal não gosta de filmes de samurai.
\end{earg}


\problempart
\label{pr.QLarguments}
Para cada argumento, escreva um quadro de simbolização e traduza o argumento para QL.
\begin{earg}
\item Nada sobre minha mesa escapa à minha atenção. Há um computador sobre minha mesa. Logo, há um computador que não escapa à minha atenção.
\item Todos os meus sonhos são em preto e branco. Programas de TV antigos são em preto e branco. Portanto, alguns dos meus sonhos são programas de TV antigos.
\item Nem Holmes nem Watson estiveram na Austrália. Uma pessoa só poderia ver um canguru se tivesse ido à Austrália ou a um zoológico. Embora Watson não tenha visto um canguru, Holmes viu. Portanto, Holmes esteve em um zoológico.
\item Ninguém espera a Inquisição Espanhola. Ninguém conhece os sofrimentos que eu vi. Portanto, qualquer um que espera a Inquisição Espanhola conhece os sofrimentos que eu vi.
\item Um antílope é maior que uma caixa de pão. Estou pensando em algo que não é maior que uma caixa de pão, e que é ou um antílope ou um melão-cantalupo. Logo, estou pensando em um melão-cantalupo.
\item Todo bebê é ilógico. Ninguém que seja ilógico consegue manejar um crocodilo. Berthold é um bebê. Portanto, Berthold é incapaz de manejar um crocodilo.
\end{earg}

\solutions
\problempart
\label{pr.QLcandies}
Usando o quadro de simbolização abaixo, traduza cada sentença da língua natural para QL.
\begin{ekey}
\item[UD:] bombons (doces)
\item[Cx:] $x$ tem chocolate.
\item[Mx:] $x$ tem marzipã.
\item[Sx:] $x$ tem açúcar.
\item[Tx:] Boris já experimentou $x$.
\item[Bxy:] $x$ é melhor que $y$.
\end{ekey}
\begin{earg}
\item Boris nunca experimentou nenhum bombom.
\item Marzipã é sempre feito com açúcar.
\item Algum bombom não tem açúcar.
\item O melhor bombom de todos é de chocolate.
\item Nenhum bombom é melhor que ele mesmo.
\item Boris nunca experimentou chocolate sem açúcar.
\item Boris já experimentou marzipã e chocolate, mas nunca juntos.
%\item Boris has tried nothing that is better than sugar-free marzipan.
\item Qualquer bombom com chocolate é melhor que qualquer bombom sem chocolate.
\item Qualquer bombom com chocolate e marzipã é melhor que qualquer bombom que não tenha nem chocolate nem marzipã.
\end{earg}



\problempart
Usando o quadro de simbolização abaixo, traduza cada sentença da língua natural para QL.
\begin{ekey}
\item[UD:] pessoas e pratos em um “potluck” (jantar colaborativo)
\item[Rx:] $x$ acabou (foi totalmente consumido).
\item[Tx:] $x$ está sobre a mesa.
\item[Fx:] $x$ é comida.
\item[Px:] $x$ é uma pessoa.
\item[Lxy:] $x$ gosta de $y$.
\item[e:] Eli
\item[f:] Francesca
\item[g:] o guacamole
\end{ekey}
\begin{earg}
\item Toda a comida está sobre a mesa.
\item Se o guacamole ainda não acabou, então ele está sobre a mesa.
\item Todo mundo gosta do guacamole.
\item Se alguém gosta do guacamole, então Eli gosta.
\item Francesca só gosta dos pratos que já acabaram.
\item Francesca não gosta de ninguém, e ninguém gosta de Francesca.
\item Eli gosta de qualquer um que gosta do guacamole.
\item Eli gosta de qualquer um que gosta das pessoas de quem Eli gosta.
\item Se há uma pessoa sobre a mesa, então toda a comida já acabou.
\end{earg}


\solutions
\problempart
\label{pr.QLballet}
Usando o quadro de simbolização abaixo, traduza cada sentença da língua natural para QL.
\begin{ekey}
\item[UD:] pessoas
\item[Dx:] $x$ dança balé.
\item[Fx:] $x$ é mulher.
\item[Mx:] $x$ é homem.
\item[Cxy:] $x$ é filho/filha de $y$.
\item[Sxy:] $x$ é irmão/irmã de $y$.
\item[e:] Elmer
\item[j:] Jane
\item[p:] Patrick
\end{ekey}
\begin{earg}
\item Todos os filhos de Patrick dançam balé.
\item Jane é filha de Patrick.
\item Patrick tem uma filha.
\item Jane é filha única.
\item Todas as filhas de Patrick dançam balé.
\item Patrick não tem filhos homens.
\item Jane é sobrinha de Elmer.
\item Patrick é irmão de Elmer.
\item Os irmãos de Patrick não têm filhos.
\item Jane é tia.
\item Toda pessoa que dança balé tem uma irmã que também dança balé.
\item Todo homem que dança balé é filho de alguém que dança balé.
\end{earg}

\problempart
\label{pr.freeQL}
Identifique, em cada fórmula, quais ocorrências de variáveis estão ligadas (bound) e quais estão livres.
\begin{earg}
\item $\exists x Lxy \eand \forall y Lyx$
\item $\forall x Ax \eand Bx$
\item $\forall x (Ax \eand Bx) \eand \forall y(Cx \eand Dy)$
\item $\forall x\exists y[Rxy \eif (Jz \eand Kx)] \eor Ryx$
\item $\forall x_1(Mx_2 \eiff Lx_2x_1) \eand \exists x_2 Lx_3x_2$
\end{earg}


\problempart
Usando o quadro de simbolização abaixo, traduza cada sentença da língua natural para QL com identidade. A última sentença é ambígua e pode ser traduzida de duas maneiras; você deve fornecer ambas as traduções. (Dica: a identidade só é necessária para as últimas quatro sentenças.)
\begin{ekey}
\item[UD:] pessoas
\item[Kx:] $x$ conhece a combinação do cofre.
\item[Sx:] $x$ é espião.
\item[Vx:] $x$ é vegetariano.
\item[Txy:] $x$ confia em $y$.
\item[h:] Hofthor
\item[i:] Ingmar
\end{ekey}
\begin{earg}
\item Hofthor é espião, mas nenhum vegetariano é espião.
\item Ninguém conhece a combinação do cofre, a menos que Ingmar conheça.
\item Nenhum espião conhece a combinação do cofre.
\item Nem Hofthor nem Ingmar são vegetarianos.
\item Hofthor confia em um vegetariano.
\item Todo mundo que confia em Ingmar confia em um vegetariano.
\item Todo mundo que confia em Ingmar confia em alguém que confia em um vegetariano.
\item Só Ingmar conhece a combinação do cofre.
\item Ingmar confia em Hofthor, mas em mais ninguém.
\item A pessoa que conhece a combinação do cofre é vegetariana.
\item A pessoa que conhece a combinação do cofre não é espiã.
\end{earg}

\solutions
\problempart
\label{pr.QLcards}
Usando o quadro de simbolização abaixo, traduza cada sentença da língua natural para QL com identidade. As duas últimas sentenças são ambíguas e podem ser traduzidas de duas maneiras; você deve fornecer ambas as traduções para cada uma.
\begin{ekey}
\item[UD:] cartas de um baralho padrão
\item[Bx:] $x$ é preta.
\item[Cx:] $x$ é de paus.
\item[Dx:] $x$ é um dois.
\item[Jx:] $x$ é valete.
\item[Mx:] $x$ é o homem com o machado.
\item[Ox:] $x$ é de olho único (valete com um olho).
\item[Wx:] $x$ é coringa (carta “wild”).
\end{ekey}
\begin{earg}
\item Todas as cartas de paus são cartas pretas.
\item Não há cartas “wild” (coringas).
\item Há pelo menos duas cartas de paus.
\item Há mais de um valete de olho único.
\item Há no máximo dois valetes de olho único.
\item Há dois valetes pretos.
\item Há quatro doses (cartas dois).
\item O dois de paus é uma carta preta.
\item Os valetes de olho único e o homem com o machado são “wild”.
\item Se o dois de paus é “wild”, então há exatamente uma carta “wild”.
\item O homem com o machado não é um valete.
\item O dois de paus não é o homem com o machado.
\end{earg}


\problempart Usando o quadro de simbolização abaixo, traduza cada sentença da língua natural para QL com identidade. As duas últimas sentenças são ambíguas e podem ser traduzidas de duas maneiras; você deve fornecer ambas as traduções para cada uma.
\begin{ekey}
\item[UD:] animais do mundo
\item[Bx:] $x$ está no campo do fazendeiro Brown.
\item[Hx:] $x$ é um cavalo.
\item[Px:] $x$ é um Pégaso.
\item[Wx:] $x$ tem asas.
\end{ekey}
\begin{earg}
\item Há pelo menos três cavalos no mundo.
\item Há pelo menos três animais no mundo.
\item Há mais de um cavalo no campo do fazendeiro Brown.
\item Há três cavalos no campo do fazendeiro Brown.
\item Há uma única criatura alada no campo do fazendeiro Brown; quaisquer outros animais no campo não têm asas.
\item O Pégaso é um cavalo alado.
\item O animal no campo do fazendeiro Brown não é um cavalo.
\item O cavalo no campo do fazendeiro Brown não tem asas.
\end{earg}
